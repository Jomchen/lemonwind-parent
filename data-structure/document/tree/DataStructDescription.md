
* 31 是个奇素数，JVM 会将 31 * i 优化为 (i << 5) - 1


* 一般二叉树
* 二叉查找树
* 真二叉树（国外叫 Full Binary Tree）国内叫 完满二叉树
   - 所有节点的度要么为0要么为2,即有 左子节点和右子节点 或 只是叶子节点
* 满二叉树（国外叫 Perfect Binary Tree）国内叫完美二叉树
   - 所有节点度数要么为0要么为2,所有的叶子节点都在同一层，所以满二叉树一定是真二叉树
   - 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多
   - 满二叉树一定是真二叉树，真二叉树不一定是满二叉树
   - 第 h 层节点数 m = 2^(h-1)，h >= 1
   - 高度h = log(n+1)，h>=1
   - 总节点个数n = (2^h) - 1，h >= 1
* 完全二叉树（国外叫 Complete Binary Tree）国内叫完全二叉树
   - 完全二叉树是在满二叉树的基础上从最底层开始，从右至左，从下至上，依次减少节点的变化而来
   - 度为 1 的节点只有左子树
   - 度为 1 的节点要么是 1 个，要么是 0 个
   - 同样节点数量的二叉树，完全二叉树的高度最小
   - 假设完全二叉树的高度为 h，那么至少有 2^(h-1) 个节点 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^(h-2) + 1
      - 高度为h，那么假设第h层节点数为1时，即数量最小，那么从根节点到h-1层节点为满二叉树，所以
      - 高度为h的完全二叉树最少节点数为：(2^(h-1) - 1) + 1 => 2^(h-1)
   - 假设完全二叉树的高度为 h，那么最多有 2^h - 1 个节点
   - 如果总节点数量为 n，那么 2^(h-1) <= n < 2^h
   - h - 1 <= log2n < h
       - h = log2n向下取整 + 1 即 h = floor(log2n) + 1
       - 这里是以 2 为底，n为真数
   - 一棵有n个节点的完全二叉树（n>0），从上到下，从左到右
      - 如果从0开始编号
          - 如果 i= 0，它是根节点
          - 如果 i > 0，它的父节点是 floor((i-1)/2)
          - 如果 2i  + 1 <= n - 1，它的左子节点编号为 2i  + 1
            -如果 2i + 2 <= n - 1，右子节点编号为 2i + 2
      - 如果从1开始编号
         - 如果 i= 1，它是根节点
         - 如果 i > 1，它的父节点是 floor(i/2)
         - 如果 2i <= n，它的左子节点编号为 2i 
         -如果 2i + 1 <= n，右子节点编号为 2i + 1
* 二叉搜索树（Binary Search Tree）
* 平衡二叉树（AVL）
   - 平衡标准比较严格：每个左右子树的高度差不超过 1
   - 最大高度是：1.44 * log(n+2) - 1.328（1000W 个节点，AVL树最大树高28）
   - 搜索，添加，删除都是 O(log(n))复杂度，其中添加仅需 O(1) 次旋转，删除最多 O(log(n)) 次旋转调整
* 红黑树
   - 平衡标准比较宽松：没有一条路径会大于其他路径的 2 倍
   - 最大高度 h = 2*log(n+1)，依然是 O(log(n)) 级别
   - 搜索，添加，删除都是 O(log(n))复杂度，其中添加，删除都仅需 O(1) 次旋转调整
   - 其它概念
      - 是一种弱平衡，黑高度平衡
      - 相比 AVL 树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍
         - 因为形成 B 树，是一个节点至少有一个红和一个黑形成
   - 注意
      - 搜索的次数远远大于插入和删除，选择 AVL 树；搜索，插入，删除次数几乎差不多，选择红黑树
      - 相对于 AVL 树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量旋转操作，整体来说性能要优于AVL树
      - 红黑树的平均统计性能优于 AVL 树，实际应用中更多选择使用红黑树
* 哈夫曼树/霍夫曼树/最优二叉树（完美二叉树）
* B-Tree 或 B-树 或 B树
* B+Tree
* B*Tree



* 树
   - 度：是某个节点不为空的子节点的个数，二叉树限定了度最大值为 2
   - 树的度：所有节点度中的最大值
   - 叶子节点：度为 0 的节点
   - 层数：根节点在第一层，根节点的子节点在第二层，以此类推（有些教程也以0层开始）
   - 节点的深度：从根节点到当前节点的唯一路径上的节点总数
   - 节点的高度：从当前节点到最远叶子节点的路径上的节点总数
   - 树的深度：所有节点深度中最大值
   - 树的高度：所有节点高度中的最大值
   - 有序树：树中任意节点的子节点之间有顺序关系
   - 无序树：树中任意节点的子节点之间没有顺序关系
   - 树的重构
      1. 给出 先序遍历 和 中序遍历 可以推导出树结构
         头 左 右 **** 左 头 右
         由于 左，右 都是子树，可以根据上面的形式递归推导
      2. 给出 后序遍历 和 中序遍历 可以推导出树结构
         左 右 头 **** 左 头 右

* 二叉树
   - 三大公式
      - 非空二叉树的第 h 层，最多有 2^(h-1) 个节点（h >= 1）
      - 在高度为 h 的二叉树上最多有 2^h - 1 个节点（h >= 1）
         `2^h - 1 == 2^0 + 2^1 + 2^2 + ... + 2^(h-1) `
      - n0 = n2 + 1 对于任何一棵非空二叉树，如果叶子节点个数为 n0，度数为1的节点个数为 n1，度为2的节点个数为 n2，总边数为 T
         ```
         n = n0 + n1 + n2（三种节点数总和就是 n）
         T = n - 1（每个节点都有指向自己的一条边，但是根节点没有，所以边数为 n - 1）
         T = n1 + 2*n2（度数为0的子边为 0；度数为1的子边为1；度数为2的子边为2；所以总边数为 0*n0 + 1*n1 + 2*n2 = n1 + 2*n2
         T = n0 + n1 + n2 - 1（由于 n = n0 + n1 + n2，所以换算公式就是 T = n - 1 = n0 + n1 + n2 - 1）

         n0 + n1 + n2 - 1 = T = n1 + 2*n2
            => n0 + n2 - 1 = 2*n2
            => n0 = 2*n2 - n2 + 1
            => n0 = n2 + 1（此公式及其重要）

            n = n0 + n1 + n2，T = n - 1
               => T = n0 + n1 + n2 - 1
               => 由 n0 = n2 + 1 换算 T = (n2 + 1) + n1 + n2 - 1 = n1 + 2*n2
               => 由 n2 = n0 - 1 换算 T = n0 + n1 + (n0 - 1) - 1 = 2*n0 + n1 - 2
         ```

    - 二叉树的高度
       ```
       public int height() {
          return Math.max(left == null ? 0 : this.left.height(), right == null ? 0 : this.right.height()) + 1;
       }
       ```

* 真二叉树
   ```
   每个节点的度数 要么为2,要么为0
   给予条件：（可以得知唯一的树结构结果）
      1. 真二叉树
      2. 先序遍历结果
      3. 后序遍历结果
   前序遍历 + 后序遍历：
      头 左 右 *** 左 右 头
      头 右 左 *** 右 左 头
   ```
   ```
      前序遍历 + 后序遍历
      如果它是一棵真二叉树(Proper Binary Tree)，结果唯一的
      不然结果不唯一
   ```


* 满二叉树的公式
   - 前 h 层相关(h>=1)
      对于一个满二叉树第 h 层的元素个数为 1*(2^(h-1)) => 2^(h-1)
      所以前 h 层的元素个数总计为：1 + 2^1 + 2^2 + 2^3 + ... + 2^(h-1)
      通过等比数列公式 a1(1 - q^h)/(1-q) => (1 - 2^h)/(1 - 2) => (1 - 2^h)/-1 => (2^h) - 1
      高度h = log(n+1)
      总节点个数n = 2^h - 1
   - 方案1：定位坐标（坐标 x 从 0 开始）
      1. 从上往下，从左往右（即层序遍历编号），结点总数为 n
      2. 第x个元素的父节点为 floor((x-1)/2)
      3. 如果 2x + 1 <= n - 1，它的左子节点编号为 2x + 1
         如果 2x + 1 > n - 1 则它无左子节点
      4. 如果 2x + 2 <= n - 1，它的右子节点编号为 2x + 2
         如果 2x + 2 > n - 1 则它无右子节点
   - 方案2：定位坐标（坐标 y 从 1 开始）
      1. 从上往下，从左往右（即层序遍历编号），结点总数为 n
      2. 某一个节点的父节点一定是 floor(y/2)
      3. 如果 2y <= n，它的左子结点编号为 2y
         如果 2y > n 则无它左子结点
      4. 如果 2y + 1 <= n，它的右子结点编号为 2y + 1
         如果 2y + 1 > n 则它无右子节点
      ```
           1
          / \
         2   3
        / \ / \
       4  5 6  7

        方案1：
           array数组为:              {1,2,3,4,5,6,7}
           array对应的索引x对应是:    0,1,2,3,4,5,6
      ```


*  完全二叉树
    ```
    度为 1 的节点只有左子树
    度为 1 的节点要么是 1 个，要么是 0 个
    同样节点数量的二叉树，完全二叉树的高度最小
    叶子节点只会出现在最后 2 层，且最后 1 层的叶子结点都靠左对齐
    ```
    ```
            A
          /   \
        B      C
       / \     /\
      D   E   F G
     /\  /
    H I J

    完全二叉树的判断方式
       通过层序遍历节点：
          1. 如果 left != null && right != null 则将 left 和 right 顺序入队
          2. 如果 left == null && right != null 则返回 false，证明不是 完全二叉树
          3. 如果 (left != null && right == null) || (left == null && right == null)
             则之后的节点只要有一个节点度数不为零则返回 false
             即，这个节点之后的所有节点都必须是叶子节点才是完全二叉树

    度为 1 的节点只有左子树
    度为 1 的节点要么是 1 个，要么是 0 个
    同样节点数量的二叉树，完全二叉树的高度最小
    至少有 2^(h-1) 个节点 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^(h-2) + 1
    至多有 2^h - 1 个节点 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^(h-1)
    总结点数量为 n：
       2^(h-1) <= n < 2^n
       h - 1 <= log(n) < h
       举例：
          h - 1 <= log(n) < h
             假设 h - 1 <= 4.2 < h，h 只能是 5
                h <= 5.2, h > 4.2，所以 h 只能是 5（向下取整）
    一些函数单词：
        ceiling(x) 对 x 向上取整
           4.0,4.2,4.5,4.7 => 5
        floor(x) 对 x 向下取整
           4.0,4.2,4.5,4.7 => 4


   面试题：
      1. 如果一棵完全二叉树有 768 个节点，求叶子节点的个数
         假设 叶子节点个数 n0，度为1的非叶结点个数 n1，度为2的非叶结点个数 n2
            n = n0 + n1 + n2，
            因为 n0 = n2 + 1，把 n2 用 n0 进行替换得到
            n = 2n0 + n1 - 1


         完全二叉树的 n1 要么为0 要么为 1
            n1 为 1 时，n = 2n0，n必然是偶数
               叶子节点个数 n0 = n/2，非叶子结点个数 n1 + n2 = n/2
            n1 为 0 时，n=2n0 - 1，n必然是奇数
               叶子节点个数 n0 = (n+1)/2，非叶子节点个数 n1 + n2 = n - ((n+1)/2) = (n-1)/2

          函数解析
             n 如果是偶数，叶子节点数 n0 = n/2
             n 如果是奇数，叶子节点数 n0 = (n+1)/2
             最终公式（适用于n为奇数或偶数时，推论如下）
                叶子节点数 n0 = (n+1)/2 = (n+1) >> 1 = ceiling(n/2)
                非叶子节点数 x = n1 + n2 = floor(n/2) = ceiling((n-1)/2)

             假设公式为 (n+1)/2 进行探讨
                假如 n 是奇数，作了加一，为的就是向上取整
                假如 n 是偶数，作了加一，完全没有任何意义
                (n+1)/2 = n/2 + 1/2，如果 n 是偶数希望消掉 1/2，可以写作 n0 = floor(n/2 + 1/2) => floor((n+1)/2)
                如果 n 是奇数则刚好满足自己的需求，如果 n 是偶数则此公式也可以套用
                综合可以推导出公式 n0 = floor((n+1)/2) => (n+1)/2 => (n+1) >> 1

             叶子节点个数 n0 = floor((n+1)/2) = ceiling(n/2)
             非叶子节点个数 n1 + n2 = floor(n/2) = ceiling((n-1)/2)
             因此叶子节点个数为 384
    ```
   
* 二叉查找树
    0. 搜索的最坏时间复杂度均可优化至 O(logn)
    1. 满足以下两者条件之一
       ```
       左子树关键字比 父节点关键字小，右子树关键字比 父节点关键字大
       左子树关键字比 父节点关键字大，右子树关键字比 父节点关键字小
       ```
    2. 前驱节点（只可能是 度为 1 或 度为 0 的节点）
       ```
       中序遍历结果，查找某一个节点的前驱节点，就是遍历结果中所在位置的左边一个节点
          如果 node.left != null, predecessor = node.left.right.right.right...，终止条件：right 为 null
          如果 node.left == null && node.parent != null, predecessor = node.parent.parent.parent...，终止条件：node 在 parent 的右子树
          如果 node.left == null && node.parent == null，那就没有前驱节点
       ```
    3. 后继节点（只可能是 度为 1 或 度为 0 的节点）
       ```
       中序遍历结果，查找某一个节点的后继节点，就是遍历结果中所在位置的右边一个节点
          如果 node.right != null, successor = node.right.left.left.left.left...，终止条件：left 为 null
          如果 node.right == null && node.parent != null，successor = node.parent.parent.parent...，终止条件：node 在 parent 的左子树
          如果 node.right == null && node.parent == null，那就没有后继节点
       ```

* 平衡二叉树
   ```
   不失衡的条件
      0 <= (height(node.left) - height(node.right)) <= 1
      从底往上找，只要将第一个失衡节点调整平衡即可（旋转方式调整）
   当在一棵平衡二叉树上添加节点时
      添加节点的 父节点 和 非祖先节点 绝不会失衡
      添加节点后可能会导致所有祖先节点都失衡
      但仅需让高度最低的的失衡节点恢复平衡即可让整棵树平衡（仅需 O(1) 次调整）
   当在一棵平衡二叉树上删除节点时
      只可能会导致父节点
      让父节点平衡后又可能导致更高层的祖先节点不平衡（最多需要 O(n) 次调整）
   平均时间复杂度
      搜索：O(log(n))
      添加：O(log(n))，仅需O(1)次的旋转操作
      删除：O(log(n))，最多需要((log(n))次的旋转操作

   旋转
      LL
         A失衡，左子树高所以先确认了L，A的左子树中左子树高所以后确认了L，所以LL，A右旋转
               A         B
             /          / \
            B      =>  C   A
          /
         C

         A失衡，左子树高所以先确认了L，A的左子树中左子树高所以后确认了L，所以LL，A右旋转
                 A            B
               /  \          / \
              B   C   =>   D   A
            /  \          /   / \
           D   E         F   E  C
          /
         F
      LR
         A失衡，左子树高所以先确认了L，A的左子树中右子树高所以后确认了R，所以LR，所以B先左旋转，再A右旋转
              A                 A                E
            /  \               / \              / \
           B   C              E   C            B   A
          /\          =>     /         =>     / \   \
         D  E               B                D   F   C
           /               / \
          F               D   F
      RR
         A失衡，右子树高所以先确认了R，A的右子树中右子树高所以后确认了R，所以RR，A左旋转
         A                  A
          \                / \
           B       =>     B   C
            \
             C

         A失衡，右子树高所以先确认了R，A的右子树中右子树高所以后确认了R，所以RR，A左旋转
           A               B
          / \             / \
         C   B           A   D
            / \    =>   / \   \
           E   D       C   E   F
                \
                 F
      RL
         A的称，右子树高所以先确认了R，A的右子树中左子树高所以后确认了L，所以RL，所以C右旋转，再A左旋转
           A            A               D
          / \          / \             / \
         B   C        B   D           A   C
            / \   =>       \     =>  / \   \
           D   E            C       B   F   E
            \              / \
             F            F   E
   ```



红黑树

   ```
   JDK8 中的 HashMap 用的是哈希数组结合 链表/红黑树实现
      单链表转为红黑树的情况
         当哈希数组中的桶容量 >= 64 且 单向链表的节点数量大于 8 时
      红黑树转为单项链表时
         红黑树中节点少于等于 8 时，由红黑树转为链表

   下溢的完全概念
      下溢节点的关键字数量必然等于 Ceil(m/2) - 2
      如果下溢节点临近的兄弟节点，有至少 Ceil(m/2) 个关键字，可以向其借一个元素
         将父节点的元素 b 插入到下溢节点的 0 位置（最小位置）
         兄弟节点的元素 a（最大关键字）替代父节点的元素 b
         这种操作其实就是：旋转
            这也是对 B 树表现最详细的图示，在 B-Tree 专项的图示没有对此处的“省略”部分作出图示
            即便是非叶子结点的删除造成的下溢需要向兄弟结点借也是如下这个道理
                      b
                  /      \
         >=Ceil(m/2),a    Ceil(m/2) - 2
                      \
                       d
                       /\
                   省略 省略

         右下角节点已经下溢，转为：

                        a
                      /   \
         >=Ceil(m/2) - 1   b,Ceil(m/2) - 1
                          /
                         d
                        /\
                   省略 省略

   4阶B树的性质
      1. 红黑树其实是 4 阶 B-Tree 的表现形式
      2. 所有节点能存储的元素个数 x：1 <= x <= 3
      3. 所有非叶子节点的子节点个数 y：2 <= y <= 4
      4. 红黑树 和 4阶B-Tree 是等价的（用 o 表示 黑，x 表示 红）
      5. BLACK 节点与它的 RED 子节点整合在一起，形成1个B树节点
      6. 红黑树的 BLACK 节点个数与 4阶B树的节点总个数相等
   4阶B树的下溢
                             55(o)
                      /               \
                  38(x)                80(x)
                  /  \                 /  \
             25(o) 46(o)            76(o) 88(o)
             /   \     \           /
         17(x) 33(x)   50(x)     72(x)

                        等价于下列的 B-Tree

                   38 - 55  -   80
                /     |      |     \
         17-25-33   46-50  72-76   88



   红黑树的性质
      1. 节点是 RED 或 BLACK
      2. 根节点是 BLACK
      3. 叶子节点（外部节点，空节点）都是 BLACK
      4. RED 节点的子节点都是 BLACK
         RED 节点的 parent 都是 BLACK
         从根节点到 叶子节点的所有路径上不能有2个连续的 RED 节点
      5. 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点
   分析
      B 树中，新元素必定是添加到叶子节点中
      4 阶 B 树所有节点的元素个数 x 都符合 1 <= x <= 3
      建议新添加的节点默认为 RED，这样能够让红黑树的性质忙满足（性质1,2,3,4,5 都满足，性质4不一定）
      如果添加的是根节点，当成 BLACK 即可
   红黑树转为 B 树后的 叶子节点可能的所有情况
      情况
         红<-黑->红（新加的元素只可能在：第一个红的左或右，第二个红的左或右）
         黑->红（新加的元素只可能在：黑的左，红的左或右）
         红<-黑（新加的元素只可能在：红的左或右，黑的右）
         黑（新加的元素只可能在：黑的左或右）
      举例
          在4阶B树中永远是以黑色元素作为节点的根
          从上往下，从左往右：红黑红 红黑红 黑红 红黑 黑

             *---- *38* <--  55  --> *80* ---*
             |        |              |       |
         17<-25->33   46->50    72<-76       88

         新添加节点（红色）有 4种情况 + 8种情况 = 12种情况
            1. 添加到 46的左边，76的右边，88的左边，88的右边
               parent 为 BLACK
               满足 4阶B树 的性质，因此不用做任何处理
            2. 添加到 17的左边，17的右边，33的左边，33的右边，50的左边，50的右边，72的左边，72的右边
               parent 为 RED(Double Red，因此新节点也是 Red)
               需要调整

   红黑树添加后的调整（新添加的元素默认是红色）

      1-4. 添加-无需修复
         结论：
            父节点是黑色节点，则新加入节点后不需要作任何处理（如果父节点是 null 证明是根节点，需要把自己变为 BLACK）
         从上往下，从左往右：红黑红 红黑红 黑红 红黑 黑

             *---- *38* <--  55  --> *80* ---*
             |        |              |       |
         17<-25->33   46->50    72<-76       88

         添加到 46的左边，76的右边，88的左边，88的右边，由于 parent 为 BLACK，所以不作处理
         结论：
            父节点为 BLACK 时，不作处理

      5-6. 添加-修复性质4 - LL/RR
         从上往下，从左往右：红黑，红黑红，黑红，红黑，黑，红，红，黑
         48,74是存在的黑节点
         52,60是新增红节点
              *----- *38* <-- 55* -------------*
              |         |                      |
         17<-25->33    46 --> *50*   *72* <-- 76
                              |  |  |   |
                             48 52 60   74

                             转为
                       红黑红，红黑红，黑，黑
                               |                  |
                       46 <-- *50 --> 52  60 <-- 72* --> 76
                              |                    |
                             48                   74
                             （这里48的位置应该是46的右子树，74的位置应该是76的左子树 ？）

         46左旋转，50变黑，46变红，指向46的指针指向50
         76右旋转，72变黑，76变红，指向76的指针指向72
         理由是黑色节点和红色节点才能构成节点（虽然一个黑色单独也可以）
         结论：
            parent 是 RED，uncle 不是 RED
               1. parent 染成 BLACK, grand 染成 RED
               2. grand 进行单旋转

      7-8. 添加-修复性质4 - LR/RL
         从上往下，从左往右：红黑，红黑红，黑红，红黑，红，黑，黑，红
         52，60是存在的黑节点
         48，74是新增红节点

                 *----- *38* <-- 55* -----------*
                 |         |                    |
            17<-25->33    46 -> *50*   *72* <- 76
                                |  |   |  |
                               48 52  60  74

                                转为
                          红黑红，红黑红，黑，黑
                                 |                    |
                          46 <-- 48 --> 50*  *74 <-- 72 --> 76
                                          |  |
                                         52  60

            50右旋转，46左旋转，48变黑，46变红，指向46的指针指向48
            72左旋转，76右旋转，72变黑，76变红，指向76的指针指向72
            结论：
               parent 是 RED，uncle 不是 RED
                  1. 自己染成 BLACK，grand 染成 RED
                  2. 进行双旋转
                     LR: parent 左旋转，grand 右旋转
                     RL: parent 右旋转，grand 左旋转

      9-12. 添加-修复性质4 - 上溢 - LL/RR/LR/RL
         从上往下，从左往右：红黑，红黑红，黑红，红黑，（10,20,30,36,48,52,60,74 作特殊说明，假设都不存在，在每种情况只存在一个，以下作说明）


                             *----- *38* <-- 55* ----------------*
                             |         |                         |
                             |         *---*                     |
                             |             |                     |
                    *17* <-- 25 -> *33*    46 -> *50*   *72* <- 76
                    |  |           |  |          |  |   |  |
                   10 20          30 36         48 52  60  74
                             这是一个假设示例

                             ----------------------------------------------------------------------------------------
                             10 如果是新增红节点 - 上溢 LL
                                新加10时，在B树中会发生上溢，所以需要提一个关键字和再上一级合并
                                理论应该是17，但是在红黑树的构成为了方便选择 25 与上面的节点合并
                             转为
                                红红黑（这里需要按12种情况再处理），黑，黑，黑红，红黑，红，黑，黑，黑，黑，黑，黑，黑
                     *----- *25* <-- 38* <-- 55* ------------*
                     |         |       |                     |
                   *17*      *33*      46 -> *50*   *72* <- 76
                   |  |      |  |            |  |   |  |
                   10 20    30 36           48 52  60  74

                             ----------------------------------------------------------------------------------------
                             36 如果是新增红节点 - 上溢 RR
                                新加36时，在B树中会发生上溢，所以需要提一个关键字和再上一级合并
                                理论应该是25
                             转为
                                红红黑（这里需要按12种情况再处理），黑，黑，黑红，红黑，黑，黑，黑，红，黑，黑，黑，黑
                     *----- *25* <-- 38* <-- 55* ------------*
                     |         |       |                     |
                   *17*      *33*      46 -> *50*   *72* <- 76
                   |  |      |  |            |  |   |  |
                   10 20    30 36           48 52  60  74

                             ----------------------------------------------------------------------------------------
                             20 如果是新增红节点 - 上溢 LR
                                新加20时，在B树中会发生上溢，所以需要提一个关键字和再上一级合并
                                理论应该是20，但是在红黑树的构成为了方便选择 25 与上面的节点合并
                             转为
                                红红黑（这里需要按12种情况再处理），黑，黑，黑红，红黑，黑，红，黑，黑，黑，黑，黑，黑
                     *----- *25* <-- 38* <-- 55* ------------*
                     |         |       |                     |
                   *17*      *33*      46 -> *50*   *72* <- 76
                   |  |      |  |            |  |   |  |
                   10 20    30 36           48 52  60  74

                             ----------------------------------------------------------------------------------------
                             30 如果是新增红节点 - 上溢 RL
                                新加30时，在B树中会发生上溢，所以需要提一个关键字和再上一级合并
                                理论应该是25
                             转为
                                红红黑（这里需要按12种情况再处理），黑，黑，黑红，红黑，黑，黑，红，黑，黑，黑，黑，黑
                     *----- *25* <-- 38* <-- 55* ------------*
                     |         |       |                     |
                   *17*      *33*      46 -> *50*   *72* <- 76
                   |  |      |  |            |  |   |  |
                   10 20    30 36           48 52  60  74

           结论：
              parent 是 RED，uncle 是 RED
              1. parent, uncle 染成 BLACK
              2. grand 向上合并
                 染成 RED，当做是新添加的节点进行处理（按12种情况处理）
                    由于 grand 向上合并时，可能继续发生上溢
                    若上溢持续到根节点，只需将根节点染成 BLACK

   红黑树删除后的调整
      红黑树的删除只可能是在叶子节点上
         即使有非叶子节点的删除也会引起前驱或后继补充，而前驱或后继一定是在叶子节点上，从而引起下溢
      分析
         从上往下，从左往右：红黑红 红黑红 黑红 红黑 黑

             *----- 38* <-- 55  -> *80* -----*
             |        |            |         |
         17<-25->33  46->50   72<-76         88

         1. 假设删除的是红色节点：
            如果删除的是 17 或 33 或 50 或 72，删除后不影响红黑树的性质，所以不处理
         2. 假设删除的是黑色节点：
            1. 如果删除的是拥有 2 个 RED 子节点的 BLACK 节点
               例如这里的 25 不可能直接删除，因为它会找它的 子节点替代删除（前驱，后继），
               然后删除前驱/后继，其实质就是删除子节点，因此此操作实质是触发删除叶子节点的情况
            2. 如果删除的是拥有 1 个 RED 子节点的 BLACK 节点
               例如这里的 46 或 76
            3. 如果删除的是 BLACK 叶子节点
               sibling 为 BLACK
                  黑sibling 形成的B树节点中没有一个 RED
                  黑sibling 形成的B树节点中有至少一个 RED
                     例如这里的 88

      0. 因为删除实际上是删除叶子结点（如果是非叶子节点也是 前驱或后继 节点替代，所以实际是删除叶子节点）
      1. 对删除的是红色节点分析
         不作处理，因为不影响平衡
      2. 对删除的是黑色节点分析
         1. 如果删除的是拥有 2 个 RED 子节点的 BLACK 节点
            不作处理（因为实际是前驱或后继补充，最终实际是B-Tree的叶子节点上）
         2. 如果删除的是拥有 1 个 RED 子节点的 BLACK 节点
            分析
            从上往下，从左往右：黑红，黑红，红黑，黑
             * - *55 --> *80* ---*
             |           |       |
            46->50  72<-76      88

            删除 46 和 76 后

            分析
            从上往下，从左往右：黑红，黑，黑，黑
             * - *55 --> *80* ---*
             |           |       |
            50          72      88
            结论：
               用以替代的子节点是 RED
                  将替代的子节点染成 BLACK 即可保持红黑树性质

         3. 如果删除的是 BLACK 叶子节点

            删除-BLACK叶子节点 - sibling 为 BLACK

               如果 sibling 至少有 1 个 RED 子节点
                  按照 B-Tree 的原理，因为兄弟是黑色，而兄弟中形成的B树节点有红的多余元素，所以可以借
                  BLACK 叶子节点删除后，会导致 B 树节点下溢（比如删除 88）

                  删除88分析
                  从上往下，从左往右：黑红，黑，黑红，黑 => 黑红，黑，黑，黑
                  这里 删除了88，再 76 的左旋，然后 80 的右旋，最后变色
                  *55 -> *80* -- *        *55 -> *78*
                  |      |       |   =>   |      |  |
                  46    76->78  88       46     76  80

                  删除88分析
                  从上往下，从左往右：黑红，黑，红黑，黑 => 黑红，黑，黑，黑
                  这里 删除了88，再 80 右旋，最后变色
                  *55 -> *80* --*         *55 -> *76*
                  |      |      |         |      |  |
                  |      * -*   |         |      |  |
                  |         |   |         |      |  |
                  46   72<-76   88        46    72  80

                  删除88分析
                  从上往下，从左往右：黑红，黑，红黑红，黑 => 黑红，黑，黑，红黑
                  这里 删除了88， 80 右旋转（或 76 左旋转，再 80 右旋转），最后变色
                   *-- *55 -> *80* ------*         *55 -> *76* ----*
                   |          |          |  =>     |      |        |
                  46     72<-76->78     88        46     72   78<-80

                  结论
                     如果 sibling 至少有 1 个 RED 子节点
                        进行旋转操作
                        旋转之后的中心节点继承 parent 颜色
                        旋转之后的中心节点的左右节点染成 BLACK

               如果 sibling 没有 1 个 RED 子节点
                  BLACK 叶子节点删除后，会导致 B 树节点下溢（比如删除 88）

                     删除88分析
                     从上往下，从左往右：黑红，黑，黑，黑 => 黑，黑，红黑
                     按照 B-Tree 的原理，兄弟是红色
                       *55 -> *80*              *55* ----*
                       |      |  |        =>    |        |  （这里是如果 parent 是非黑色的情况）
                       46     76 88            46   76<-80

                     删除88分析
                     从上往下，从左往右：黑，黑，黑 => 空，红黑
                       *80*                  x --*      （这里是 parent 是黑色的情况）
                       |  |            =>        |      （这里的 80 原来的位置下溢，当做删除节点作下溢处理）
                       76 88              76 <- 80

                     结论：
                        sibling 没有 1 个 RED 子节点
                           将 sibling 染成 RED，parent 染成 BLACK 即可修复红黑树性质
                           如果 parent 以前是 BLACK
                              会导致 parent 下溢
                              这时只需要把 parent 当做被删除节点处理即可（即下溢处理）

            删除-BLACK叶子节点 - sibling 为 RED

               删除88分析
               从上往下，从左往右：红黑，黑，黑，黑 => 黑红，黑，黑，黑 => 黑，黑，红黑
               *55* <- 80* --*           *55 --> *80*                       *55* -------*
               |  |          |    =>     |       |  |   => 再删除 88    =>  |           |
               46 76         88         46      76  88     按照逻辑处理    46    76 <- 80


               结论：
                  如果 sibling 是 RED
                     sibling 染成 BLACK，parent 染成 RED，parent 进行旋转
                     此时删除相应的元素就又回到 sibling 是 BLACK 的情况
   ```



* B-Tree
   - 概念
      ```
         每个节点的所有子树高度一致
         m 阶：表示一个节点最多存储 m - 1 个关键字（m >= 2），最多有 m 个子节点
         根节点关键字个数 x：1 <= x <= m - 1
         非根节点关键字个数 x：Ceil(m/2) - 1 <= x <= m - 1
         如果有子节点，子节点个数 y：x + 1
            根节点：2 <= y <= m
            非根节点：Ceil(m/2) <= y <= m
        // TODO 这里可能有问题
         注意：如果一个非叶子节点关键字个数为 n，则这个节点的子节点要么为 0 要么为 n+1
      ```

   - 添加
      - 添加关键字必然是在叶子节点上添加，添加之后可能造成当前节点的关键字个数达到 m，所以发生上溢，最终可能传播到根节点
      ```
     处理，m阶B树上溢的方案
        1. 当节点关键字达到 m 时，发生上溢
        2. 假设上溢节点最中间关键字位置为 k
        3. 将 k 位置的关键字向上与父节点合并
        4. 将 [0, k-1] 和 [k+1, m-1] 位置的关键字分裂成2个子节点
        5. 由于父节点新加了个关键字所以可能导致父节点再次上溢，以同样的原理再次处理
      ```
      
   - 删除
      ```
      情况分析：
         所有的删除操作都在叶子节点上，即使删除的是非叶子节点的关键字，也会有前驱或后继进行弥补，而前驱或后继一定是
         在叶子节点上（可能引起下溢）

      情况一，关键字在叶子节点上
         如果删除后还满足大于等于 Ceil(m/2) - 1，则直接删除就可以了，否则删除后使之发生下溢

      情况二，关键字不在叶子节点
         找到这个关键字的 前驱 或 后继 关键字，复制到当前关键字所在位置，然后删除 原前驱或后继（可能造成下溢）
            发生下溢节点的元素数量 必然等于 ceil(m/2) - 2
            前驱：这个关键字左子树中的最大关键字
            后继：这个关键字右子树中的最小关键字
            前驱 或 后继 都肯定是在叶子结点上，所以删除其实都是发生在叶子节点上
            原来 前驱 或 后继 的所在节点被删除后可能等于 Ceil(m/2) - 2，从而触发当前节点“下溢”
            从而可能以上传播可能直到根节点

      处理，m阶B树下溢的方案
         下溢节点的元素数量必然等于 Ceil(m/2) - 2
         注意！！
            如果下溢到了根节点，根节点自己也不够则只能合并，根节点没有兄弟元素

            1. 如果下溢节点的临近的兄弟节点，有至少 Ceil(m/2) 个关键字，可以向其借一个元素
               将父节点的元素 b 插入到下溢节点的 0 位置（最小位置）
               用兄弟节点的元素 a（最大关键字）替代父节点的元素 b
               这种操作就是旋转

                                         b
                                     /      \
            >=Ceil(m/2), a    Ceil(m/2) - 2

            右下角节点已经下溢，转为：

                                           a
                                         /   \
                >=Ceil(m/2) - 1     b, Ceil(m/2) - 1

            ------------------------------------

            1（详细）.下溢的向兄弟节点借关键字的 详细解释（这个相比上一个才最准确）
                                             b
                                         /      \
                >=Ceil(m/2),  a    Ceil(m/2) - 2
                                         \
                                          d
                                          /\
                                      省略 省略

                右下角节点已经下溢，转为：

                                           a
                                         /   \
                >=Ceil(m/2) - 1    b, Ceil(m/2) - 1
                                             /
                                            d
                                           /\
                                      省略 省略
            ------------------------------------

            2. 如果下溢节点临近兄弟节点，只有 Ceil(m/2) - 1 个关键字，不满足借关键字
               将父节点的元素 b 挪下来跟左右子节点进行合并
               合并后的节点关键字个数等于 Ceil(m/2) + Ceil(m/2) - 2，不超过 m - 1
               这个操作可能导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播
                                          abc
                                        /      \
               >=Ceil(m/2) - 1      Ceil(m/2) - 2

            右下角节点已经下溢，转为：

                                            a         c
                                        /         |       \
            其它 >=Ceil(m/2) - 1,     b,      Ceil(m/2) - 2   其它
      ```



* 其它网址
   - 小马哥推荐的网站
      - http://520it.com/binarytrees/ 
      - http://btv.melezinek.cz/binary-search-tree.html 
      - http://ww.cs.usfca.edu/~galles/visualization/Algorithms.html 
      - http://www.codelike.in 
   - 一些动态生成数据结构的网址 李明杰，MJ大神精选，恋上数据结构
      - http://520it.com/binarytrees/
      - https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
   - 可以在线构建数据结构
      - http://520it.com/binarytrees/
      - https://www.cs.usfca.edu/~galles/visualization/BTree.html
      - https://www.cnblogs.com/mjios/p/10627814.html#toc_title_1
   - 最完整数据结构视频和源码
      - https://pan.baidu.com/s/1Rbf2xE4bwplMiicPHthbwQ gkmk
      - https://www.bilibili.com/video/BV1Ey4y1k7NS?p=316
      - 恋上数据结构与算法
         - https://pan.baidu.com/s/1lbJ-YBqSLH7MEP0O1A5OMQ 提取码:g81i
   - 小码哥官方网站
      - https://github.com/CoderMJLee
      - https://cnblogs.com/mjios
   - 打印二叉树的结构的源码 https://github.com/CoderMJLee/BinaryTrees
      - 注意：https://www.cs.usfca.edu/~galles/visualization/BTree.html 添加 4 阶 B-Tree，关键字由 1 ~ 22
         - 添加完成后，删除 14 关键字可造成即可能 需要前驱/后继 也可能需要 向兄弟元素借关键字 的下溢情况
         - 添加完成后，删除 13 关键字也可能产生相同的矛盾情况

