* 大数乘法
   - 按照小学时学习的乘法运算，在进行 n 位数之间的相乘时，需要大约进行 n^2 次个位数的相乘
   - 思路
   ```
   解法1：
      1. 乘法粒化
         36        36        36       36
       * 54   +   *54   +   *54  +   *54
      ------     -----     -----    ------
         24       120       300      1500

      上面分别是对于基位权值的乘法
      6*4        30*4       6*50     30*50

      2. 相加：
      最终数值字符串如下：
        24
       120
       300
      1500
      两层数值字符串相加，相加方式并不是数值直接相加
      是基于基位相加再判断进位的方式形成新的数值字符串
      把新形成的数值字符串和下一层按相同方式相加，直到总体只剩下一层

   解法2：分治的优化算法（W X Y Z ? 相当于是四个位数的基位）
                    *------*------*
                    |  A   |  B   |
                    *------*------*
                    |  C   |  D   |
      x             *------*------*
      -----------------------------
      
      |  W   |  X   |  Y   |  Z   |
      
      *-------------*
      |     A C     |  ?      ?
      *-------------*              
                    *-------------*
         ?      ?   |     B D     |
                    *-------------*
             *-------------*
         ?   |     B C     |  ?
             *-------------*
             *-------------*
         ?   |     A D     |  ?
             *-------------*
   
   解法2：基于分治再优化算法(Karatsuba)
      BC + AD = AC + BD - (A - B)(C - D)

                    *------*------*
                    |  A   |  B   |
                    *------*------*
                    |  C   |  D   |
      x             *------*------*
      -----------------------------
      *-------------*
      |     A C     |
      *-------------*
                    *-------------*
                    |     B D     |
                    *-------------*
             *-------------*
             |     A C     |
             *-------------*
             *-------------*
             |     B D     |
             *-------------*
             *-------------*
             | (A-B)(C-D)  |
             *-------------*
      因为 AC 和 BD 已经计算过了，所以相较于之前的分治算法要少做些乘法
   ```

* Sequence 串
   - 概念
      - 字符串，前缀(prefix)，真前缀(proper prefix)，后缀(suffix)，真后缀(proper suffix)
      - "thank" 字符串
         1. 前缀：t, th, tha, than, thank
         2. 真前缀：t, th, tha, than
         3. 后缀：thank, hank, ank, nk, k
         4. 真后缀：hank, ank, nk, k
      - 举例
         ```
         *----------*-------------------------------*------------------------------------*------------------*
         |  模式串  |            真前缀             |               真后缀               | 最大公共子串长度 |
         *----------*-------------------------------*------------------------------------*------------------*
         | ABCDABCE | A,AB,ABC,ABCDA,ABCDAB,ABCDABC | BCDABCE,CDABCE,DABCE,ABCE,BCE,CE,E |          0       |
         | ABCDAB   | A,AB,ABC,ABCD,ABCDA,ABCDAB    | BCDABC,CDABC,DABC,ABC,BC,C         |          3       |
         | ABCDAB   | A,AB,ABC,ABCD,ABCDA           | BCDAB,CDAB,DAB,AB,B                |          2       |
         | ABCDA    | A,AB,ABC,ABCD                 | BCDA,CDA,DA,A                      |          1       |
         | ABCD     | A,AB,ABC                      | BCD,CD,D                           |          0       |
         | ABC      | A,AB                          | BC,C                               |          0       |
         | AB       | A                             | B                                  |          0       |
         | A        |                               |                                    |          0       |
         *----------*-------------------------------*------------------------------------*------------------*
         ```
   - 蛮力算法
   - KMP 算法
      - KMP 主逻辑
         - 最好时间复杂度：O(m)
         - 最坏时间复杂度：O(n)，不超过O(2n)
         - m 是模式串的长度，n 是文本串的长度
      - next 表的构造过程跟y KMP 主体逻辑类似
         - 时间复杂度：O(m)
      - KMP 整体
         - 最好时间复杂度：O(m)
         - 最坏时间复杂度：O(n + m)
         - 空间复杂度：O(m)
      - pattern图解计算 next 表
         ```
                              n                             i
         *-----*-----*-----*-----*-----*-----*-----*-----*-----*
         |  A  | ... |  A  |  X  | ### |  A  | ... |  A  |  Y  |
         *-----*-----*-----*-----*-----*-----*-----*-----*-----*
               | k|
               *--* 
         已知 前面的 A...A 与后面的 A...A 完全相同的
         ```
      0. 已知 next[i] == n
      1. 如果 Pattern[i] == Pattern[n]
         - 那么 next[i + 1] == n + 1
      2. 如果 Pattern[i] != Pattern[n]
         - 已知 next[n] == k
         - 如果 Pattern[i] == Pattern[k]
            - 那么 next[i + 1] == k + 1
         - 如果 Pattern[i] != Pattern[k]
            - 将 k 代入 n，重复执行 2步骤
      - 优化策略
         - 假设模式串和文本串在文本串的字符d匹配失败
         - 已知 next[i] == n, next[n] == k
         - 如果 Pattern[i] != d，就让模式串滑动到 next[i]（也就是n）位置跟d进行比较
         - 如果 Pattern[n] != d，就让模式串滑动到 next[n]（也就是k）位置跟d进行比较
         - 如果 Pattern[i] == Pattern[n]，那么当 i 位置失配时，模式串最终必然会滑到 k 位置跟 d 进行比较
         - 所以 next[i] 直接存储 next[n]（也就是k）即可
   - Boyer-Moore 算法，简称 BM 算法
      - 概念
         - 最好时间复杂度：O(n/m)，最坏时间复杂度：O(n + m)
         - 该算法从模式串的尾部开始匹配（自后向前）
      - BM 算法的移动字符数是通过 2 侧影响最大值
         - 坏字符规则（Bad Character，简称BC）
            ```
            当 Pattern 中的字符 E 和 Text 中的 S 失配时，称 S 为“坏字符”
            如果 Pattern 的未匹配子串的不存在坏字符，直接将 Pattern 移动到坏字符的下一位
               Pattern 是由自己的最右端开始往自身的左边自查
            否则，让 Pattern 的未匹配子串中最靠右的坏字符与 Text 中的坏字符对齐
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
            | H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
            
            1. pattern 从右至左和 text 进行匹配，首先发现 S 和 E是不匹配，那么定义 S 为坏字符
                                      #
            *---*---*---*---*---*---*---*
            | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*
                                        2. 上面的 pattern，由于 pattern 中 最右边的 E 之前的序列皆是未匹配字符，且其中不存在 S，
                                           所以 pattern 头部移动到 text 坏字符（S）的下一位开始匹配
                                                                  #
                                        *---*---*---*---*---*---*---*
                                        | E | X | A | M | P | L | E |
                                        *---*---*---*---*---*---*---*
                                                3. 上面的 pattern 从右至左和 text 进行匹配，发现 P 和 E 不匹配，那么定义 P 为坏字符
                                                   那么 pattern 的这个E左边的皆为未匹配字符，发现其中存在 P 且为最靠右的
                                                   让 pattern 中的这个最靠右的 P 和 text 的坏字符 P 进行对齐，再让 pattern 从右至左进行匹配
                                                          #
                                                *---*---*---*---*---*---*---*
                                                | E | X | A | M | P | L | E |
                                                *---*---*---*---*---*---*---*
                                                            4. 上面的 pattern 再根据相同规则匹配发现 I 和 A 不匹配，那么定义 I 为坏字符
                                                               在 pattern 中 A 左边不存在 I，所以 pattern 头部移动并与坏字符下一个字符对齐再进行匹配
                                                                                      #
                                                            *---*---*---*---*---*---*---*
                                                            | E | X | A | M | P | L | E |
                                                            *---*---*---*---*---*---*---*
                                                            
                                                            其它步骤省略。。。。。。 
                                                            


            ```
         - 好后缀规则（Good Suffix，简称GS）
            ```
            当 pattern 中的字符 E 和 text 中的 S 失配时，称 S 为“坏字符”
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
            | H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
                                      #
            *---*---*---*---*---*---*---*
            | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*                         #
                                        *---*---*---*---*---*---*---*
                                        | E | X | A | M | P | L | E |
                                        *---*---*---*---*---*---*---*
                                                          #
                                                *---*---*---*---*---*---*---*
                                                | E | X | A | M | P | L | E |
                                                *---*---*---*---*---*---*---*
                                                                        以上的移动是根据“坏字符”规则，而下面的图是根据“好后缀”规则移动的
                                                                        *---*---*---*---*---*---*---*
                                                                        | E | X | A | M | P | L | E |
                                                                        *---*---*---*---*---*---*---*
            pattern 由右至左地进行匹配
            "MPLE" 是一个成功匹配的后缀，"E", "LE", "PLE", "MPLE" 都是“好后缀”
            如果 pattern 中找不到与好后缀对齐的子串，直接将 pattern 移动到好后缀的下一位
            否则，从 pattern 中找出子串与 text 中的好后缀对齐
            ```
   - Rabin-Karp 算法
      - Rabin-Karp 算法（或 Karp-Rabin 算法），简称 RK 算法，是一种基于 hash 的字符串匹配算法
      - 由 Richard M.Karp 和 Michael O.Rabin 于 1987 年发明
      - 大致原理
         - 将 Pattern 的 hash 值与 Text 中每个子串的 hash 值进行比较
         - 某一子串的 hash 值可以根据上一子串的 hash 值在 O(1) 时间内计算出来
   - Sunday
      - Sunday 算法由 Daniel M.Sunday 在1990年提出，它的思想跟BM算法很相似
      - 从前向后匹配
      - 当匹配失败时，关注的是 text 中参与匹配的子串的下一位字符 A
         - 如果 A 没有在 pattern 中出现，则直接跳过，即移动位数 = pattern长度 + 1
         - 否则，让 pattern 中最靠右的 A 与 text 中的 A 对齐
