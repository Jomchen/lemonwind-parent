* 大数乘法
   - 按照小学时学习的乘法运算，在进行 n 位数之间的相乘时，需要大约进行 n^2 次个位数的相乘
   - 思路
   ```
   解法1：
      1. 乘法粒化
         36        36        36       36
       * 54   +   *54   +   *54  +   *54
      ------     -----     -----    ------
         24       120       300      1500

      上面分别是对于基位权值的乘法
      6*4        30*4       6*50     30*50

      2. 相加：
      最终数值字符串如下：
        24
       120
       300
      1500
      两层数值字符串相加，相加方式并不是数值直接相加
      是基于基位相加再判断进位的方式形成新的数值字符串
      把新形成的数值字符串和下一层按相同方式相加，直到总体只剩下一层

   解法2：分治的优化算法（W X Y Z ? 相当于是四个位数的基位）
                    *------*------*
                    |  A   |  B   |
                    *------*------*
                    |  C   |  D   |
      x             *------*------*
      -----------------------------
      
      |  W   |  X   |  Y   |  Z   |
      
      *-------------*
      |     A C     |  ?      ?
      *-------------*              
                    *-------------*
         ?      ?   |     B D     |
                    *-------------*
             *-------------*
         ?   |     B C     |  ?
             *-------------*
             *-------------*
         ?   |     A D     |  ?
             *-------------*
   
   解法2：基于分治再优化算法(Karatsuba)
      BC + AD = AC + BD - (A - B)(C - D)

                    *------*------*
                    |  A   |  B   |
                    *------*------*
                    |  C   |  D   |
      x             *------*------*
      -----------------------------
      *-------------*
      |     A C     |
      *-------------*
                    *-------------*
                    |     B D     |
                    *-------------*
             *-------------*
             |     A C     |
             *-------------*
             *-------------*
             |     B D     |
             *-------------*
             *-------------*
             | (A-B)(C-D)  |
             *-------------*
      因为 AC 和 BD 已经计算过了，所以相较于之前的分治算法要少做些乘法
   ```

* Sequence 串
   - 概念
      - 字符串，前缀(prefix)，真前缀(proper prefix)，后缀(suffix)，真后缀(proper suffix)
      - "thank" 字符串
         1. 前缀：t, th, tha, than, thank
         2. 真前缀：t, th, tha, than
         3. 后缀：thank, hank, ank, nk, k
         4. 真后缀：hank, ank, nk, k
      - 举例
         ```
         *----------*-------------------------------*------------------------------------*------------------*
         |  模式串  |            真前缀             |               真后缀               | 最大公共子串长度 |
         *----------*-------------------------------*------------------------------------*------------------*
         | ABCDABCE | A,AB,ABC,ABCDA,ABCDAB,ABCDABC | BCDABCE,CDABCE,DABCE,ABCE,BCE,CE,E |          0       |
         | ABCDAB   | A,AB,ABC,ABCD,ABCDA,ABCDAB    | BCDABC,CDABC,DABC,ABC,BC,C         |          3       |
         | ABCDAB   | A,AB,ABC,ABCD,ABCDA           | BCDAB,CDAB,DAB,AB,B                |          2       |
         | ABCDA    | A,AB,ABC,ABCD                 | BCDA,CDA,DA,A                      |          1       |
         | ABCD     | A,AB,ABC                      | BCD,CD,D                           |          0       |
         | ABC      | A,AB                          | BC,C                               |          0       |
         | AB       | A                             | B                                  |          0       |
         | A        |                               |                                    |          0       |
         *----------*-------------------------------*------------------------------------*------------------*
         ```
   - 蛮力算法
   - KMP 算法
      - KMP 主逻辑
         - 最好时间复杂度：O(m)
         - 最坏时间复杂度：O(n)，不超过O(2n)
         - m 是模式串的长度，n 是文本串的长度
      - next 表的构造过程跟y KMP 主体逻辑类似
         - 时间复杂度：O(m)
      - KMP 整体
         - 最好时间复杂度：O(m)
         - 最坏时间复杂度：O(n + m)
         - 空间复杂度：O(m)
      - pattern图解计算 next 表
         ```
                              n                             i
         *-----*-----*-----*-----*-----*-----*-----*-----*-----*
         |  A  | ... |  A  |  X  | ### |  A  | ... |  A  |  Y  |
         *-----*-----*-----*-----*-----*-----*-----*-----*-----*
               | k|
               *--* 
         已知 前面的 A...A 与后面的 A...A 完全相同的
         ```
      0. 已知 next[i] == n
      1. 如果 Pattern[i] == Pattern[n]
         - 那么 next[i + 1] == n + 1
      2. 如果 Pattern[i] != Pattern[n]
         - 已知 next[n] == k
         - 如果 Pattern[i] == Pattern[k]
            - 那么 next[i + 1] == k + 1
         - 如果 Pattern[i] != Pattern[k]
            - 将 k 代入 n，重复执行 2步骤
      - 优化策略
         - 假设模式串和文本串在文本串的字符d匹配失败
         - 已知 next[i] == n, next[n] == k
         - 如果 Pattern[i] != d，就让模式串滑动到 next[i]（也就是n）位置跟d进行比较
         - 如果 Pattern[n] != d，就让模式串滑动到 next[n]（也就是k）位置跟d进行比较
         - 如果 Pattern[i] == Pattern[n]，那么当 i 位置失配时，模式串最终必然会滑到 k 位置跟 d 进行比较
         - 所以 next[i] 直接存储 next[n]（也就是k）即可
   - Boyer-Moore 算法，简称 BM 算法
      - 概念
         - 最好时间复杂度：O(n/m)，最坏时间复杂度：O(n + m)
         - 该算法从模式串的尾部开始匹配（自后向前）
      - BM 算法的移动字符数是通过 2 侧影响最大值
         - 坏字符规则（Bad Character，简称BC）
            ```
            当 Pattern 中的字符 E 和 Text 中的 S 失配时，称 S 为“坏字符”
            如果 Pattern 的未匹配子串的不存在坏字符，直接将 Pattern
               Pattern 是由自己的最右端开始往自身的左边自查
            否则，让 Pattern 的未匹配子串中最靠右的坏字符与 Text 中的坏字符对齐
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
            | H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*
            
            *---*---*---*---*---*---*---*
            | E | X | A | M | P | L | E |
            *---*---*---*---*---*---*---*
                                        *---*---*---*---*---*---*---*
                                        | E | X | A | M | P | L | E |
                                        *---*---*---*---*---*---*---*
                                                *---*---*---*---*---*---*---*
                                                | E | X | A | M | P | L | E |
                                                *---*---*---*---*---*---*---*
                                                            *---*---*---*---*---*---*---*
                                                            | E | X | A | M | P | L | E |
                                                            *---*---*---*---*---*---*---*
                                                            
                                                            其它步骤省略。。。。。。 
                                                            


            ```
         - 好后缀规则（Good Suffix，简称GS）
            ```
            ```
            ```
