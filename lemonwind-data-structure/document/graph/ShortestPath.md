## 最短路径（Shortest Path）
* 最短路径是指两顶点之间权值之和最小路径（有向图，无向图均适用，不能有负权环）
   - 负权边：是指边的权值为负数时（具体情况具体分析）
   - 负权环：是指在有负权情况下还有环的情况
      - 假如 A 出发 再到 A 那么会形成一个环
      - 如果环上经过的权值总和为负数，则会不断兜圈子，所以得到的最短路径会任意小

* 算法
   - 有负权环时，是不存在最短路径的（不论以何种算法，因为在一个点到自身的循环可以无限减小总的路径权值）
   - 算法分类
      - 单源最短路径算法（只计算某个顶点到其它顶点的最短路径）
         - Dijkstra（迪杰斯特拉算法）
         - Bellman-Ford（贝尔曼-福特算法）
      - 多源路径算法（计算出任意两顶点之间的最短路径）
         - Floyd（弗洛伊德算法）
   - 算法解析
      1. Dijkstra
         - 注意
            - 不能有负权值的边存在
         - 概念
            - 属于单源最短路径算法，用于计算一个顶点到其它所有顶点的最短路径
            - 条件：不能有负权边
            - 时间复杂度：可以优化至 O(ElogV)，E 是边数量，V 是节点数量
            - 想象：顶点看作石头，边看作绳子，俯视整张图，把某一个顶点往上拉，那么整个过程石头被提起的先后会根据 距离被触动的石头最短的石头
         - 算法步骤
            1. 从源点开始，这个源点提起来了
            2. 一旦有节点起来了，更新或添加与这个刚起来的节点直连的节点的最短路径值（就是松弛操作）
               - 如果直连节点的最短路径值不存在则把本次计算的路径值存放之
               - 如果直连节点的最短路径值存在，但是新的比旧的值小，则覆盖，否则不处理
            3. 对记录有最短路径值的顶点，拿到达某个顶点所需路径最小的顶点 提起来
            4. 重复执行第 2 步操作，直到所有顶点都起来为止
            5. 总结：
               1. 拉起一个顶点
               2. 对新起来的点进行松弛（比较与“新起来的点”直连的“所在点”到“源点”的最短路径，比旧最短路径更短才能更新）
               3. 对未起来的点，选择到源点路径最小的点作为新的起来的点（即第一步操作）
                  - 直到所有点都起来为止
            
         - 一些概念
            - 后起来的顶点一定是基于之前起来的顶点联系才可能起来的，
               - 只是需要判断是被哪个顶点关联起来的（一般是被松弛后的最短路径的关联起来）
            - 松弛：更新2个顶点之间的最短路径
               - 这里一般是指：更新源点到另一个的最短路径
               - 例如确定A到D的最短路径后，对DC, DE边进行松弛操作就是更新了 A 到 C，A 到 E 的最短路径
            - 算法
               - 假设先提起 A（A 先触动），与 A 直连的边中 edge1 最短，则先崩直，edge1 另一头的顶点 B 被触动
               - B 触动，与 B 直连的边中 和 与 A 直连的边中比较，发现最短的边 edge2 先崩直，edge2 另一头的 C 被触动（要排除之前崩直的边）
               - 以此类推分别与 C,B,A 直连的边中比较，最短的 edge3 会崩直，因此这个边 edge3 相连的 D 会被触动（要排除之前崩直的边）
               - 以此类推，最后崩直的边就是 A 到那个边所在顶点的最短路径（要排除之前崩直的边）
                 - 最后崩直的绳子就是 A 到其它小石头的最短路径
                 - 松弛操作：更新 2 个顶点之间的最短路径
                    - 但是注意在这个过程中，可能会有新到达以前某顶点的权值更小，此时就要更新下之前到达顶点的路径
                    - 松弛操作的目的在于尝试找出最短的路径
      2. Bellman-Ford
         - 概念
            - 也属于单源最短路径算法，支持负权边，还能检测出是否有 负权环
         - 算法
            - 算法原理：对所有的边进行 V - 1 次松弛操作（V 是节点数量），得到所有可能的最短路径
            - 时间复杂度：O(EV), E 是边数，V 是节点数量
            - 注意这里的 V - 1 是指：除了起始顶点之外的顶点个数减一，实际上是 总顶点个数 - 2
         - 注意
            - 支持负权边，可以检测出负权环
         - 算法
            ```
              -3   1    1    1
            A -> B -> C -> D -> E
            假如以上是一张图
            
            最好的情况是对所有的边从左至右进行一次松弛操作就能计算出A到达其他所有顶点的最短路径，过程如下
            对 A-B 边松弛，得到 the shortest path from A to B is -3 
            对 B-C 边松弛，得到 the shortest path from A to C is -2 
            对 C-D 边松弛，得到 the shortest path from A to D is -1 
            对 D-E 边松弛，得到 the shortest path from A to D is 0 
            
            最坏的情况，过程如下
            对 D-E 边松弛，松弛失败，因为都不知道 A 到 D 的路径值 
            对 C-D 边松弛，松弛失败，因为都不知道 A 到 C 的路径值 
            对 B-C 边松弛，松弛失败，因为都不知道 A 到 B 的路径值 
            对 A-B 边松弛，得到 the shortest path from A to B is -3
            
            对 D-E 边松弛，松弛失败，因为都不知道 A 到 D 的路径值 
            对 C-D 边松弛，松弛失败，因为都不知道 A 到 C 的路径值 
            对 B-C 边松弛，得到 the shortest path from A to C is -2 
            对 A-B 边松弛，得到 the shortest path from A to B is -3
            
            之后的过程省略
            ```
      3. Floyd
         - 概念
            - 属于多源最短路径算法，能够求出任意2个顶点之间的最短路径，支持 负权边
            - 时间复杂度：O(V^3)，效率比执行 V 次 Dijkstra 算法要好（V 是顶点数量）
         - 注意
            - 支持负权边
         - 算法
            - 从任意顶点 i 到任意顶点 j 的最短路径不外乎两种可能
               1. 直接从 i 到 j
               2. 从 i 经过若干个顶点到 j
            - 假设 dist(i, j) 为顶点 i 到顶点 j 的最短路径的距离
            - 对于每一个顶点 k，检查 dist(i, k) + dist(k, j) < dist(i, j) 是否成立
               - 如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，设置 dist(i, j) = dist(i, k) + dist(k, j)
               - 当我们遍历完所有节点k, dist(i, j)中记录的便是 i 到 j 的最短路径的距离


